<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      Home
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1668059" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=6682698><div class="accordion-heading child"><a href="Cluster.html">Cluster</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Cluster.html#eval">eval</a></li><li data-type='method'><a href="Cluster.html#fetchClientValue">fetchClientValue</a></li><li data-type='method'><a href="Cluster.html#kill">kill</a></li><li data-type='method'><a href="Cluster.html#request">request</a></li><li data-type='method'><a href="Cluster.html#respawn">respawn</a></li><li data-type='method'><a href="Cluster.html#send">send</a></li><li data-type='method'><a href="Cluster.html#spawn">spawn</a></li></ul></li><li class="accordion collapsed child" id=8250516><div class="accordion-heading child"><a href="ClusterClient.html">ClusterClient</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterClient.html#.getInfo">getInfo</a></li><li data-type='method'><a href="ClusterClient.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterClient.html#evalOnCluster">evalOnCluster</a></li><li data-type='method'><a href="ClusterClient.html#evalOnManager">evalOnManager</a></li><li data-type='method'><a href="ClusterClient.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterClient.html#request">request</a></li><li data-type='method'><a href="ClusterClient.html#respawnAll">respawnAll</a></li><li data-type='method'><a href="ClusterClient.html#send">send</a></li></ul></li><li class="accordion collapsed child" id=9857985><div class="accordion-heading child"><a href="ClusterManager.html">ClusterManager</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterManager.html#_debug">_debug</a></li><li data-type='method'><a href="ClusterManager.html#broadcast">broadcast</a></li><li data-type='method'><a href="ClusterManager.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterManager.html#createCluster">createCluster</a></li><li data-type='method'><a href="ClusterManager.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterManager.html#respawnAll">respawnAll</a></li></ul></li></ul> </div><div class="accordion collapsed" id="7206701" > <h3 class="accordion-heading">Events<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Client.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:death">death</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:disconnect">disconnect</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:ready">ready</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:reconnecting">reconnecting</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:spawn">spawn</a></li><li class="accordion-list" id=""><a href="ClusterClient.html#event:message">message</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:clusterCreate">clusterCreate</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:debug">debug</a></li><li class="accordion-list" id=""><a href="Shard.html#event:message">message</a></li></ul> </div><div class="accordion collapsed" id="1453581" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#ClusterSpawnOptions">ClusterSpawnOptions</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      

      



    









    


    <section class="readme">
        <article><p align="center"><a href="https://nodei.co/npm/discord-hybrid-sharding/"><img src="https://nodei.co/npm/discord-hybrid-sharding.png"></a></p>
<p align="center"><img src="https://img.shields.io/npm/v/discord-hybrid-sharding"> <img src="https://img.shields.io/npm/dm/discord-hybrid-sharding?label=downloads"> <img src="https://img.shields.io/npm/l/discord-hybrid-sharding"> <img src="https://img.shields.io/github/repo-size/meister03/discord-hybrid-sharding">  <a href="https://discord.gg/YTdNBHh"><img src="https://discordapp.com/api/guilds/697129454761410600/widget.png" alt="Discord server"/></a></p>
<h1>Discord-Hybrid-Sharding</h1>
<p>The first package which combines sharding manager &amp; internal sharding to save a lot of resources, which allows clustering!</p>
<p>In other words: &quot;Mixing both: if you need <code>x</code> shards for <code>n</code> process!&quot;</p>
<p><strong><a href="#Use-with-other-libraries">NEW: Clustering Support for all JS Libraries</a></strong></p>
<p>If you are interested in auto-scaling &amp; cross-hosting on other machines, check out this package <code>npmjs.com/discord-cross-hosting</code></p>
<h2>Why?</h2>
<p>The sharding manager is very heavy and uses more than 300MB per shard during light usage, while internal sharding uses just 20% of it. Internal sharding reaches its' limits at 14000 guilds and becomes slow when your bot gets bigger.</p>
<p>Your only solution becomes converting to the sharding manager. That's why this new package will solve all your problems (tested by many bots with 20-170k guilds), because it spawns shards, which has internal shards. <strong>You can save up to 60% on resources!</strong></p>
<ul>
<li><strong>Decentralized ClusterEval function -&gt; Listenerless, less memory leaks &amp; cluster/client doesn't have to be ready</strong></li>
<li><strong>Heartbeat System -&gt; Respawn unresponsive or dead <code>ClusterClient</code>s</strong></li>
<li><strong>IPC System -&gt; Client &lt;-&gt; ClusterManager -&gt; <code>.request()</code>, <code>.reply()</code>, <code>.send()</code></strong></li>
<li><strong>Fine-grained control over the cluster queue -&gt; <code>manager.queue.next(), .stop(), .resume()</code></strong></li>
<li>Memory efficient -&gt; 60% less memory when clustering</li>
<li>Debug event -&gt; A good overview of cluster information</li>
<li>EvalOnManager function &amp; other cool functions you need...</li>
<li><code>Strings</code> &amp; <code>Functions with Context</code> support on <code>.broadcastEval()</code></li>
<li>Optional timeout feature on <code>.broadcastEval()</code> to prevent memory leaks</li>
<li><strong><a href="https://npmjs.com/discord-cross-hosting">Supports cross-hosting: <code>Shard/Cluster</code> managing and cross-host communication (<code>.broadcastEval()</code>, <code>IPC</code>)</a></strong></li>
<li><strong><a href="https://npmjs.com/discord-cross-ratelimit">Supports syncing Discord rate limits globally</a></strong>
<strong>Scroll down to check our new functions!</strong></li>
</ul>
<h2>How does it work?</h2>
<p>There are clusters/master shards, which behave like regular shards in the sharding manager and spawns clusters in addition to internal shards. You do not have to spawn as many regular Shards (master shards), which can be replaced with internal shards.
&quot;for process <code>n</code> , <code>n</code> internal shards&quot;</p>
<p>Example: <code>A Discord bot with 4000 guilds</code>
Normally we would spawn 4 shards with the Sharding Manager (<code>~4 x 300MB memory</code>), but in this case we start with 2 clusters/master shards, which spawns 2 internal shards ==&gt; We just saved 2 shards in comparison to the regular Sharding Manager (<code>~2 x 300MB memory</code>).</p>
<h3>See below for the Guide</h3>
<p><strong>If you need help, feel free to join our <a href="https://discord.gg/YTdNBHh">Discord server</a>. ☺</strong></p>
<h1>Download</h1>
<pre class="prettyprint source lang-cli"><code>npm i discord-hybrid-sharding
------ or ---------------------
yarn add discord-hybrid-sharding
</code></pre>
<h1>Discord.js v13</h1>
<ul>
<li>Full Discord.js v13 support</li>
<li><code>Strings</code> and <code>Functions</code> with <code>context</code> are supported in <code>.broadcastEval()</code></li>
<li>Most public methods accept sole objects, such as <code>.spawn({ amount: 20, timeout: -1 })</code></li>
<li>Very similar functions to the Discord.js ShardingManager and more for the advanced usage</li>
</ul>
<h1>Setting up</h1>
<p><strong><a href="https://sharding.js.org">Click to open documentation</a></strong></p>
<p>First, add the module into your project (into your shard/cluster file).
Filename: <code>Cluster.js</code></p>
<pre class="prettyprint source lang-js"><code>const Cluster = require('discord-hybrid-sharding');

const manager = new Cluster.Manager(`${__dirname}/bot.js`, {
    totalShards: 7, // or 'auto'
    /// Check below for more options
    shardsPerClusters: 2,
    // totalClusters: 7,
    mode: 'process', // you can also choose &quot;worker&quot;
    token: 'YOUR_TOKEN',
});

manager.on('clusterCreate', cluster => console.log(`Launched Cluster ${cluster.id}`));
manager.spawn({ timeout: -1 });
</code></pre>
<p>After that, insert the code below into your <code>bot.js</code> file</p>
<pre class="prettyprint source lang-js"><code>const Cluster = require('discord-hybrid-sharding');
const Discord = require('discord.js');

const client = new Discord.Client({
    shards: Cluster.data.SHARD_LIST, // An array of shards that will get spawned
    shardCount: Cluster.data.TOTAL_SHARDS, // Total number of shards
});

client.cluster = new Cluster.Client(client); // initialize the Client, so we access the .broadcastEval()
client.login('YOUR_TOKEN');
</code></pre>
<h1>Eval-ing over clusters</h1>
<p><em>Following examples assume that your <code>Discord.Client</code> is called <code>client</code>.</em></p>
<pre class="prettyprint source lang-js"><code>client.cluster
    .broadcastEval(`this.guilds.cache.size`)
    .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`));

// or with a callback function
client.cluster
    .broadcastEval(c => c.guilds.cache.size)
    .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`));
</code></pre>
<h1>Cluster.Manager</h1>
<table>
<thead>
<tr>
<th>Option</th>
<th>Type</th>
<th>Default</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>totalShards</td>
<td>number or string</td>
<td>&quot;auto&quot;</td>
<td>Amount of internal shards which will be spawned</td>
</tr>
<tr>
<td>totalClusters</td>
<td>number or string</td>
<td>&quot;auto&quot;</td>
<td>Amount of processes/clusters which will be spawned</td>
</tr>
<tr>
<td>shardsPerClusters</td>
<td>number or string</td>
<td>-</td>
<td>Amount of shards which will be in one process/cluster</td>
</tr>
<tr>
<td>shardList</td>
<td>Array[number]</td>
<td>-</td>
<td>OPTIONAL - On cross-hosting or spawning specific shards you can provide a shardList of internal Shard IDs, which will get spawned</td>
</tr>
<tr>
<td>mode</td>
<td>&quot;worker&quot; or &quot;process&quot;</td>
<td>&quot;worker&quot;</td>
<td>Cluster.Manager mode for the processes</td>
</tr>
<tr>
<td>token</td>
<td>string</td>
<td>-</td>
<td>OPTIONAL -Bot token is only required totalShards are set to &quot;auto&quot;</td>
</tr>
</tbody>
</table>
<p>The Manager.spawn options are the same as for Sharding Manager</p>
<h1>Cluster Events</h1>
<table>
<thead>
<tr>
<th>Event</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>clusterCreate</td>
<td>Triggered when a Cluster gets spawned</td>
</tr>
</tbody>
</table>
<h1>Cluster Client Properties</h1>
<p>All properties like for <code>.broadcastEval()</code> are available, just replace the <code>client.shard</code> with <code>client.cluster</code>
Other properties:</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>client.cluster.count</td>
<td>Returns the amount of all clusters</td>
</tr>
<tr>
<td>client.cluster.id</td>
<td>Returns the current cluster ID</td>
</tr>
<tr>
<td>client.cluster.ids</td>
<td>Returns all internal shards of the cluster</td>
</tr>
</tbody>
</table>
<p><strong>Feel free to contribute/suggest or contact me on my Discord server or in DM: Meister#9667</strong></p>
<h1>Changes | Migrating to Discord-Hybrid-Sharding</h1>
<p>Options are now labelled as <code>cluster</code> instead of <code>shard</code>:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard...
+ client.cluster...

- .broadcastEval((c, context) => c.guilds.cache.get(context.guildId), { context: { guildId: '1234' }, shard: 0 })
+ .broadcastEval((c, context) => c.guilds.cache.get(context.guildId), { context: { guildId: '1234' }, cluster: 0 })
</code></pre>
<p>Small changes in naming conventions:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard.respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 })
+ client.cluster.respawnAll({ clusterDelay = 5000, respawnDelay = 5500, timeout = 30000 })

- manager.shard.respawnAll({ shardDelay = 5000, respawnDelay = 500, timeout = 30000 })
+ manager.respawnAll({ clusterDelay = 5000, respawnDelay = 5500, timeout = 30000 })

</code></pre>
<p>Get current cluster ID:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard.id
+ client.cluster.id
</code></pre>
<p>Get current shard ID:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard.id
+ message.guild.shardId
</code></pre>
<p>Get total shards count:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard.count
+ client.cluster.info.TOTAL_SHARDS
</code></pre>
<p>Get all ShardID's in the current cluster:</p>
<pre class="prettyprint source lang-diff"><code>- client.shard.id
+ [...client.cluster.ids.keys()]
</code></pre>
<h1>New functions &amp; events:</h1>
<h2><code>HeartbeatSystem</code></h2>
<ul>
<li>Checks if Cluster/Client sends a heartbeat on a given interval</li>
<li>When the Client doesn't send a heartbeat, it will be marked as dead/unresponsive</li>
<li>Cluster will get respawned after the given amount of missed heartbeats has been reached</li>
</ul>
<pre class="prettyprint source lang-js"><code>const manager = new Cluster.Manager(`${__dirname}/bot.js`, {
    totalShards: 8,
    shardsPerClusters: 2,
    keepAlive: {
        interval: 2000, // Interval to send a heartbeat
        maxMissedHeartbeats: 5, // Maximum amount of missed Heartbeats until Cluster will get respawned
        maxClusterRestarts: 3, // Maximum Amount of restarts that can be performed in 1 hour in the HeartbeatSystem
    },
});
</code></pre>
<h2><code>EvalOnCluster</code></h2>
<p>Decentralized ClusterClient eval function that doesn't open any listeners and minimizes the risk of creating a memory leak during <code>.broadcastEval()</code></p>
<ul>
<li>Build-in eval timeout which resolves after a given time</li>
<li>No additional listeners - less memory leaks, better than <code>.broadCastEval()</code></li>
<li>Client &amp; all clusters don't need to be ready</li>
</ul>
<pre class="prettyprint source lang-js"><code>client.cluster.evalOnCluster('this.cluster.id', { cluster: 0, timeout: 10000 });
</code></pre>
<h2><code>IPC System</code></h2>
<ul>
<li>The IPC System allows you to listen to your messages</li>
<li>You can communicate between the cluster and the client</li>
<li>This allows you to send requests from the client to the cluster and reply to them and vice versa</li>
<li>You can also send normal messages which do not need to be replied</li>
</ul>
<p>ClusterManager | <code>cluster.js</code></p>
<pre class="prettyprint source lang-js"><code>const Cluster = require('discord-hybrid-sharding');
const manager = new Cluster.Manager(`${__dirname}/testbot.js`, {
    totalShards: 1,
    totalClusters: 1,
});

manager.on('clusterCreate', cluster => {
    cluster.on('message', message => {
        console.log(message);
        if (!message._sRequest) return; // Check if the message needs a reply
        message.reply({ content: 'hello world' });
    });
    setInterval(() => {
        cluster.send({ content: 'I am alive' }); // Send a message to the client
        cluster.request({ content: 'Are you alive?', alive: true }).then(e => console.log(e)); // Send a message to the client
    }, 5000);
});
manager.spawn({ timeout: -1 });
</code></pre>
<p>ClusterClient | <code>client.js</code></p>
<pre class="prettyprint source lang-js"><code>const Cluster = require('discord-hybrid-sharding');
const Discord = require('discord.js');
const client = new Discord.Client({
    shards: Cluster.data.SHARD_LIST, // An array of shards that will get spawned
    shardCount: Cluster.data.TOTAL_SHARDS, // Total number of shards
});

client.cluster = new Cluster.Client(client);
client.cluster.on('message', message => {
    console.log(message);
    if(!message._sRequest) return; // Check if the message needs a reply
    if(message.alive) message.reply({ content: 'Yes I am!' }):
});
setInterval(() => {
    client.cluster.send({ content: 'I am alive as well!' });
}, 5000);
client.login('YOUR_TOKEN');
</code></pre>
<h2>Control Cluster queue:</h2>
<p>With a complex code-base, you probably need a fine-grained control over the cluster spawn queue in order to respect rate limits.</p>
<p>The queue system can be controlled from the cluster manager.</p>
<pre class="prettyprint source lang-js"><code>const manager = new Cluster.Manager(`${__dirname}/bot.js`, {
    totalShards: 8,
    shardsPerClusters: 2,
    queue: {
        auto: false,
    },
});
</code></pre>
<p>The <code>auto</code> property is set with <code>true</code> by default, which automatically queues the clusters, when running <code>manager.spawn()</code></p>
<p>When the auto mode has been disabled, then you have to manually manage the queue.</p>
<p>Cluster.js</p>
<pre class="prettyprint source lang-js"><code>manager.spawn();
manager.queue.next();
</code></pre>
<p>The <code>manager.queue.next()</code> function will spawn the next cluster in the queue.
Now you can call the function <code>client.cluster.spawnNextCluster()</code> from the client to spawn the next cluster.</p>
<table>
<thead>
<tr>
<th>Property</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>manager.queue.start()</td>
<td>Starts the queue and resolves, when the queue is empty</td>
</tr>
<tr>
<td>manager.queue.stop()</td>
<td>Stops the queue and blocks all <code>.next</code> requests</td>
</tr>
<tr>
<td>manager.queue.resume()</td>
<td>Resumes the queue and allows <code>.next</code> requests again</td>
</tr>
<tr>
<td>manager.queue.next()</td>
<td>Spawns the next cluster in the queue</td>
</tr>
<tr>
<td>client.cluster.spawnNextCluster()</td>
<td>Triggers the spawn of the next cluster in the queue</td>
</tr>
</tbody>
</table>
<h2>Other Features:</h2>
<p>Evals a Script on the ClusterManager:</p>
<pre class="prettyprint source"><code>client.cluster.evalOnManager('process.memoryUsage().rss / 1024 ** 2');
</code></pre>
<p>Listen to debug messages and internal stuff:</p>
<pre class="prettyprint source"><code>manager.on('debug', console.log);
</code></pre>
<p>Optional Timeout on broadcastEval (Promise will get rejected after given time):</p>
<pre class="prettyprint source"><code>client.cluster.broadcastEval('new Promise((resolve, reject) => {})', { timeout: 10000 });
</code></pre>
<p>Open a PR/Issue when you need other Functions :)</p>
<h1>Use with other libraries:</h1>
<p>Using the package with other libraries requires some minor changes:</p>
<ul>
<li>The Cluster.js will stay the same, scroll up to get the Code</li>
<li>Your Bot.js file will have some additional code</li>
</ul>
<pre class="prettyprint source lang-js"><code>const Cluster = require('discord-hybrid-sharding');

///Create your Discord Client:
/* Use the Data below for telling the Client, which shards to spawn */
const lastShard = Cluster.data.LAST_SHARD_ID;
const firstShard = Cluster.data.FIRST_SHARD_ID;
const totalShards = Cluster.data.TOTAL_SHARDS;
const shardList = Cluster.data.SHARD_LIST;

client.cluster = new Cluster.Client(client);

///When the Client is ready, You can listen to the client's ready event:
client.cluster.triggerReady();
</code></pre>
<p><strong>The upper code is a pseudo code and shows how you can use this package with other libraries</strong></p>
<p>With some minor changes, you can even use this Package for clustering normal processes.</p>
<h1>Bugs, glitches and issues</h1>
<p>If you encounter any problems feel free to open an issue in our <a href="https://github.com/meister03/discord-hybrid-sharding/issues">GitHub repository or join the Discord server.</a></p>
<h1>Credits</h1>
<p>Credits goes to the discord.js library for the Base Code (See <code>changes.md</code>) and to this helpful <a href="https://discord.gg/BpeedKh">server</a></p></article>
    </section>






    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Cluster","link":"<a href=\"Cluster.html\">Cluster</a>"},{"title":"Cluster#eval","link":"<a href=\"Cluster.html#eval\">Cluster &rtrif; eval</a>"},{"title":"Cluster#fetchClientValue","link":"<a href=\"Cluster.html#fetchClientValue\">Cluster &rtrif; fetchClientValue</a>"},{"title":"Cluster#kill","link":"<a href=\"Cluster.html#kill\">Cluster &rtrif; kill</a>"},{"title":"Cluster#request","link":"<a href=\"Cluster.html#request\">Cluster &rtrif; request</a>"},{"title":"Cluster#respawn","link":"<a href=\"Cluster.html#respawn\">Cluster &rtrif; respawn</a>"},{"title":"Cluster#send","link":"<a href=\"Cluster.html#send\">Cluster &rtrif; send</a>"},{"title":"Cluster#spawn","link":"<a href=\"Cluster.html#spawn\">Cluster &rtrif; spawn</a>"},{"title":"ClusterClient","link":"<a href=\"ClusterClient.html\">ClusterClient</a>"},{"title":"ClusterClient.getInfo","link":"<a href=\"ClusterClient.html#.getInfo\">ClusterClient &rtrif; getInfo</a>"},{"title":"ClusterClient#broadcastEval","link":"<a href=\"ClusterClient.html#broadcastEval\">ClusterClient &rtrif; broadcastEval</a>"},{"title":"ClusterClient#evalOnCluster","link":"<a href=\"ClusterClient.html#evalOnCluster\">ClusterClient &rtrif; evalOnCluster</a>"},{"title":"ClusterClient#evalOnManager","link":"<a href=\"ClusterClient.html#evalOnManager\">ClusterClient &rtrif; evalOnManager</a>"},{"title":"ClusterClient#fetchClientValues","link":"<a href=\"ClusterClient.html#fetchClientValues\">ClusterClient &rtrif; fetchClientValues</a>"},{"title":"ClusterClient#request","link":"<a href=\"ClusterClient.html#request\">ClusterClient &rtrif; request</a>"},{"title":"ClusterClient#respawnAll","link":"<a href=\"ClusterClient.html#respawnAll\">ClusterClient &rtrif; respawnAll</a>"},{"title":"ClusterClient#send","link":"<a href=\"ClusterClient.html#send\">ClusterClient &rtrif; send</a>"},{"title":"ClusterManager","link":"<a href=\"ClusterManager.html\">ClusterManager</a>"},{"title":"ClusterManager#_debug","link":"<a href=\"ClusterManager.html#_debug\">ClusterManager &rtrif; _debug</a>"},{"title":"ClusterManager#broadcast","link":"<a href=\"ClusterManager.html#broadcast\">ClusterManager &rtrif; broadcast</a>"},{"title":"ClusterManager#broadcastEval","link":"<a href=\"ClusterManager.html#broadcastEval\">ClusterManager &rtrif; broadcastEval</a>"},{"title":"ClusterManager#createCluster","link":"<a href=\"ClusterManager.html#createCluster\">ClusterManager &rtrif; createCluster</a>"},{"title":"ClusterManager#fetchClientValues","link":"<a href=\"ClusterManager.html#fetchClientValues\">ClusterManager &rtrif; fetchClientValues</a>"},{"title":"ClusterManager#respawnAll","link":"<a href=\"ClusterManager.html#respawnAll\">ClusterManager &rtrif; respawnAll</a>"},{"title":"error","link":"<a href=\"Client.html#event:error\">error</a>"},{"title":"death","link":"<a href=\"Cluster.html#event:death\">death</a>"},{"title":"disconnect","link":"<a href=\"Cluster.html#event:disconnect\">disconnect</a>"},{"title":"error","link":"<a href=\"Cluster.html#event:error\">error</a>"},{"title":"ready","link":"<a href=\"Cluster.html#event:ready\">ready</a>"},{"title":"reconnecting","link":"<a href=\"Cluster.html#event:reconnecting\">reconnecting</a>"},{"title":"spawn","link":"<a href=\"Cluster.html#event:spawn\">spawn</a>"},{"title":"message","link":"<a href=\"ClusterClient.html#event:message\">message</a>"},{"title":"clusterCreate","link":"<a href=\"ClusterManager.html#event:clusterCreate\">clusterCreate</a>"},{"title":"debug","link":"<a href=\"ClusterManager.html#event:debug\">debug</a>"},{"title":"message","link":"<a href=\"Shard.html#event:message\">message</a>"},{"title":"ClusterSpawnOptions","link":"<a href=\"global.html#ClusterSpawnOptions\">ClusterSpawnOptions</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    


  </body>

</html>