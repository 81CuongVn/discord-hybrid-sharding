<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      ClusterClient.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/heading.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="5671342" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=9924777><div class="accordion-heading child"><a href="Cluster.html">Cluster</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Cluster.html#eval">eval</a></li><li data-type='method'><a href="Cluster.html#fetchClientValue">fetchClientValue</a></li><li data-type='method'><a href="Cluster.html#kill">kill</a></li><li data-type='method'><a href="Cluster.html#respawn">respawn</a></li><li data-type='method'><a href="Cluster.html#send">send</a></li><li data-type='method'><a href="Cluster.html#spawn">spawn</a></li></ul></li><li class="accordion collapsed child" id=349673><div class="accordion-heading child"><a href="ClusterClient.html">ClusterClient</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterClient.html#.getinfo">getinfo</a></li><li data-type='method'><a href="ClusterClient.html#.singleton">singleton</a></li><li data-type='method'><a href="ClusterClient.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterClient.html#evalOnCluster">evalOnCluster</a></li><li data-type='method'><a href="ClusterClient.html#evalOnManager">evalOnManager</a></li><li data-type='method'><a href="ClusterClient.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterClient.html#respawnAll">respawnAll</a></li><li data-type='method'><a href="ClusterClient.html#send">send</a></li></ul></li><li class="accordion collapsed child" id=1373895><div class="accordion-heading child"><a href="ClusterManager.html">ClusterManager</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterManager.html#_debug">_debug</a></li><li data-type='method'><a href="ClusterManager.html#broadcast">broadcast</a></li><li data-type='method'><a href="ClusterManager.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterManager.html#createCluster">createCluster</a></li><li data-type='method'><a href="ClusterManager.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterManager.html#respawnAll">respawnAll</a></li><li data-type='method'><a href="ClusterManager.html#spawn">spawn</a></li></ul></li></ul> </div><div class="accordion collapsed" id="348596" > <h3 class="accordion-heading">Events<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Client.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:death">death</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:disconnect">disconnect</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:ready">ready</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:reconnecting">reconnecting</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:spawn">spawn</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:clusterCreate">clusterCreate</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:debug">debug</a></li><li class="accordion-list" id=""><a href="Shard.html#event:message">message</a></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        ClusterClient.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const Discord = require('discord.js');
const { Events } = Discord.Constants
const Util = Discord.Util;
///communicates between the master workers and the process
class ClusterClient {
  /**
  * @param {Client} client Client of the current cluster
  */
  constructor(client, usev13) {
    /**
     * Client for the Cluser
     * @type {Client}
     */
    this.client = client;

    /**
     * Mode the Cluster was spawned with
     * @type {ClusterManagerMode}
     */
    this.mode = this.info.CLUSTER_MANAGER_MODE;
    let mode = this.mode;


    /**
    * Ongoing promises for calls to {@link ClusterManager#evalOnCluster}, mapped by the `script` they were called with
    * @type {Map&lt;string, Promise>}
    * @private
    */
    this._nonce = new Map();


    this.usev13 = usev13 || false;
    /**
     * Message port for the master process (only when {@link ClusterClientUtil#mode} is `worker`)
     * @type {?MessagePort}
     */
    this.parentPort = null;

    if (mode === 'process') {
      process.on('message', this._handleMessage.bind(this));
      client.on('ready', () => {
        process.send({ _ready: true });
      });
      client.on('disconnect', () => {
        process.send({ _disconnect: true });
      });
      client.on('reconnecting', () => {
        process.send({ _reconnecting: true });
      });
    } else if (mode === 'worker') {
      this.parentPort = require('worker_threads').parentPort;
      this.parentPort.on('message', this._handleMessage.bind(this));
      client.on('ready', () => {
        this.parentPort.postMessage({ _ready: true });
      });
      client.on('disconnect', () => {
        this.parentPort.postMessage({ _disconnect: true });
      });
      client.on('reconnecting', () => {
        this.parentPort.postMessage({ _reconnecting: true });
      });
    }

  }
  /**
 * cluster's id
 * @type {number}
 * @readonly
 */
  get id() {
    return this.info.CLUSTER;
  }
  /**
  * Array of shard IDs of this client
  * @type {number[]}
  * @readonly
  */
  get ids() {
    return this.client.ws.shards;
  }
  /**
  * Total number of clusters
  * @type {number}
  * @readonly
  */
  get count() {
    return this.info.CLUSTER_COUNT;
  }
  /**
  * Gets several Info like Cluster_Count, Number, Totalshards...
  * @type {Object}
  * @readonly
  */
  get info() {
    let clustermode = process.env.CLUSTER_MANAGER_MODE;
    if (!clustermode) return
    if (clustermode !== "worker" &amp;&amp; clustermode !== "process") throw new Error("NO CHILD/MASTER EXISTS OR SUPPLIED CLUSTER_MANAGER_MODE IS INCORRECT");
    let data;
    if (clustermode === "process") {
      const shardlist = [];
      let parseshardlist = process.env.SHARD_LIST.split(",")
      parseshardlist.forEach(c => shardlist.push(Number(c)))
      data = { SHARD_LIST: shardlist, TOTAL_SHARDS: Number(process.env.TOTAL_SHARDS), CLUSTER_COUNT: Number(process.env.CLUSTER_COUNT), CLUSTER: Number(process.env.CLUSTER), CLUSTER_MANAGER_MODE: clustermode }
    } else {
      data = require("worker_threads").workerData
    }
    return data;
  }
  /**
  * Sends a message to the master process.
  * @param {*} message Message to send
  * @returns {Promise&lt;void>}
  * @emits Cluster#message
  */
  send(message) {
    //console.log(message)
    return new Promise((resolve, reject) => {
      if (this.mode === 'process') {
        process.send(message, err => {
          if (err) reject(err);
          else resolve();
        });
      } else if (this.mode === 'worker') {
        this.parentPort.postMessage(message);
        resolve();
      }
    });
  }
  /**
 * Fetches a client property value of each shard, or a given shard.
 * @param {string} prop Name of the client property to get, using periods for nesting
 * @param {number} [shard] Shard to fetch property from, all if undefined
 * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>}
 * @example
 * client.shard.fetchClientValues('guilds.cache.size')
 *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
 *   .catch(console.error);
 * @see {@link ClusterManager#fetchClientValues}
 */
  fetchClientValues(prop, shard) {
    return new Promise((resolve, reject) => {
      const parent = this.parentPort || process;

      const listener = message => {
        if (!message || message._sFetchProp !== prop || message._sFetchPropShard !== shard) return;
        parent.removeListener('message', listener);
        if (!message._error) resolve(message._result);
        else reject(Util.makeError(message._error));
      };
      parent.on('message', listener);

      this.send({ _sFetchProp: prop, _sFetchPropShard: shard }).catch(err => {
        parent.removeListener('message', listener);
        reject(err);
      });
    });
  }

  /**
   * Evaluates a script or function on all clusters, or a given cluster, in the context of the {@link Client}s.
   * @param {string|Function} script JavaScript to run on each cluster
   * @param {number} [cluster] Cluster to run script on, all if undefined
   * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Results of the script execution
   * @example
   * client.cluster.broadcastEval('this.guilds.cache.size')
   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
   *   .catch(console.error);
   * @see {@link ClusterManager#broadcastEval}
   */
  broadcastEval(script, cluster) {
    if (this.usev13) {

      return new Promise((resolve, reject) => {
        const options = cluster || {};

        const parent = this.parentPort || process;
        if (typeof script !== 'function') {
          reject(new TypeError('CLUSTERING_INVALID_EVAL_BROADCAST'));
          return;
        }

        script = `(${script})(this, ${JSON.stringify(options.context)})`;
        const listener = message => {
          if (message._sEval !== script || message._sEvalShard !== options.cluster) return;
          parent.removeListener('message', listener);
          if (!message._error) resolve(message._result);
          else reject(Util.makeError(message._error));
        };
        parent.on('message', listener);
        this.send({ _sEval: script, _sEvalShard: options.cluster }).catch(err => {
          parent.removeListener('message', listener);
          reject(err);
        });
      })

    }
    return new Promise((resolve, reject) => {
      const parent = this.parentPort || process;
      script = typeof script === 'function' ? `(${script})(this)` : script;

      const listener = message => {
        if (!message || message._sEval !== script || message._sEvalShard !== cluster) return;
        parent.removeListener('message', listener);
        if (!message._error) resolve(message._result);
        else reject(Util.makeError(message._error));
      };
      parent.on('message', listener);

      this.send({ _sEval: script, _sEvalShard: cluster }).catch(err => {
        parent.removeListener('message', listener);
        reject(err);
      });
    });
  }

   /**
 * Evaluates a script or function on the Cluster Manager
 * @param {string|Function} script JavaScript to run on the Manager
 * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Result of the script execution
 * @example
 * client.cluster.evalOnManager('process.uptime')
 *   .then(result => console.log(result))
 *   .catch(console.error);
 * @see {@link ClusterManager#evalOnManager}
 */
  evalOnManager(script) {
    return new Promise((resolve, reject) => {
      const parent = this.parentPort || process;
      script = typeof script === 'function' ? `(${script})(this)` : script;

      const listener = message => {
        if (!message || message._sManagerEval !== script) return;
        parent.removeListener('message', listener);
        if (!message._error) resolve(message._result[0]);
        else reject(Util.makeError(message._error));
      };
      parent.on('message', listener);

      this.send({ _sManagerEval: script }).catch(err => {
        parent.removeListener('message', listener);
        reject(err);
      });
    })
  }

 /**
   * Evaluates a script or function on the ClusterClient
   * @param {string|Function} script JavaScript to run on the ClusterClient
   * @param {Object} options Some options such as the TargetCluster or the Evaltimeout
   * @param {number} [options.cluster] The Id od the target Cluster
   * @param {number} [options.timeout=10000] The time in ms to wait, until the eval will be rejected without any response
   * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Result of the script execution
   * @example
   * client.cluster.evalOnCluster('this.cluster.id',  {timeout: 10000, cluster: 0})
   *   .then(result => console.log(result))
   *   .catch(console.error);
   * @see {@link ClusterManager#evalOnCluster}
   */
  evalOnCluster(script, options = {}) {
    return new Promise((resolve, reject) => {
      if (!options.hasOwnProperty('cluster')) reject('TARGET CLUSTER HAS NOT BEEN PROVIDED');
      script = typeof script === 'function' ? `(${script})(this)` : script;
      const nonce = Date.now().toString(36) + Math.random().toString(36);
      this._nonce.set(nonce, { resolve, reject });
      if (!options.timeout) options.timeout = 10000;
      setTimeout(() => {
        if (this._nonce.has(nonce)) {
          this._nonce.get(nonce).reject(new Error("EVAL Request Timed out"));
          this._nonce.delete(nonce);
        }
      }, options.timeout);
      this.send({ _sClusterEval: script, nonce, timeout: options.timeout, cluster: options.cluster });
    })
  }

  /**
   * Requests a respawn of all clusters.
   * @param {number} [clusterDelay=5000] How long to wait between clusters (in milliseconds)
   * @param {number} [respawnDelay=500] How long to wait between killing a cluster's process/worker and restarting it
   * (in milliseconds)
   * @param {number} [spawnTimeout=30000] The amount in milliseconds to wait for a cluster to become ready before
   * continuing to another. (-1 or Infinity for no wait)
   * @returns {Promise&lt;void>} Resolves upon the message being sent
   * @see {@link ClusterManager#respawnAll}
   */
  respawnAll(clusterDelay = 5000, respawnDelay = 500, spawnTimeout = 30000) {
    return this.send({ _sRespawnAll: { clusterDelay, respawnDelay, spawnTimeout } });
  }

  /**
   * Handles an IPC message.
   * @param {*} message Message received
   * @private
   */
  async _handleMessage(message) {
    if (!message) return;
    if (message._fetchProp) {
      const props = message._fetchProp.split('.');
      let value = this.client;
      for (const prop of props) value = value[prop];
      this._respond('fetchProp', { _fetchProp: message._fetchProp, _result: value });
    } else if (message._eval) {
      try {
        this._respond('eval', { _eval: message._eval, _result: await this.client._eval(message._eval) });
      } catch (err) {
        this._respond('eval', { _eval: message._eval, _error: Util.makePlainError(err) });
      }
    } else if (message.hasOwnProperty('_sClusterEvalRequest')) {
      try {
        this._respond('evalOnCluster', { _sClusterEvalResponse: await this.client._eval(message._sClusterEvalRequest), nonce: message.nonce, cluster: message.cluster });
      } catch (err) {
        this._respond('evalOnCluster', { _sClusterEvalResponse: {}, _error: Util.makePlainError(err), nonce: message.nonce });
      }
    } else if (message.hasOwnProperty('_sClusterEvalResponse')) {
      const promise = this._nonce.get(message.nonce);
      if (!promise) return;
      if (message._error) {
        promise.reject(message._error)
        this._nonce.delete(message.nonce);
      } else {
        promise.resolve(message._sClusterEvalResponse)
        this._nonce.delete(message.nonce);
      }
      return;
    }
  }

  /**
   * Sends a message to the master process, emitting an error from the client upon failure.
   * @param {string} type Type of response to send
   * @param {*} message Message to send, which can be a Object or a String
   * @private
   */
  _respond(type, message) {
    this.send(message).catch(err => {
      let error = { err };

      error.message = `Error when sending ${type} response to master process: ${err.message}`;
      /**
       * Emitted when the client encounters an error.
       * @event Client#error
       * @param {Error} error The error encountered
       */
      this.client.emit(Events.ERROR, error);
    });
  }

  /**
   * Creates/gets the singleton of this class.
   * @param {Client} client The client to use
   * @param {ClusterManagerMode} mode Mode the cluster was spawned with
   * @returns {ShardClientUtil}
   */
  static singleton(client, mode) {
    if (!this._singleton) {
      this._singleton = new this(client, mode);
    } else {
      client.emit(
        Events.WARN,
        'Multiple clients created in child process/worker; only the first will handle clustering helpers.',
      );
    }
    return this._singleton;
  }
  /**
   * gets the total Internalshardcount and shard list.
   * @returns {ClusterClientUtil}
   */
  static getinfo() {
    let clustermode = process.env.CLUSTER_MANAGER_MODE;
    if (!clustermode) return
    if (clustermode !== "worker" &amp;&amp; clustermode !== "process") throw new Error("NO CHILD/MASTER EXISTS OR SUPPLIED CLUSTER_MANAGER_MODE IS INCORRECT");
    let data;
    if (clustermode === "process") {
      const shardlist = [];
      let parseshardlist = process.env.SHARD_LIST.split(",")
      parseshardlist.forEach(c => shardlist.push(Number(c)))
      data = { SHARD_LIST: shardlist, TOTAL_SHARDS: Number(process.env.TOTAL_SHARDS), CLUSTER_COUNT: Number(process.env.CLUSTER_COUNT), CLUSTER: Number(process.env.CLUSTER), CLUSTER_MANAGER_MODE: clustermode }
    } else {
      data = require("worker_threads").workerData
    }
    return data;
  }


}
module.exports = ClusterClient;
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Cluster","link":"<a href=\"Cluster.html\">Cluster</a>"},{"title":"Cluster#eval","link":"<a href=\"Cluster.html#eval\">Cluster &rtrif; eval</a>"},{"title":"Cluster#fetchClientValue","link":"<a href=\"Cluster.html#fetchClientValue\">Cluster &rtrif; fetchClientValue</a>"},{"title":"Cluster#kill","link":"<a href=\"Cluster.html#kill\">Cluster &rtrif; kill</a>"},{"title":"Cluster#respawn","link":"<a href=\"Cluster.html#respawn\">Cluster &rtrif; respawn</a>"},{"title":"Cluster#send","link":"<a href=\"Cluster.html#send\">Cluster &rtrif; send</a>"},{"title":"Cluster#spawn","link":"<a href=\"Cluster.html#spawn\">Cluster &rtrif; spawn</a>"},{"title":"ClusterClient","link":"<a href=\"ClusterClient.html\">ClusterClient</a>"},{"title":"ClusterClient.getinfo","link":"<a href=\"ClusterClient.html#.getinfo\">ClusterClient.getinfo &rtrif; undefined</a>"},{"title":"ClusterClient.singleton","link":"<a href=\"ClusterClient.html#.singleton\">ClusterClient.singleton &rtrif; undefined</a>"},{"title":"ClusterClient#broadcastEval","link":"<a href=\"ClusterClient.html#broadcastEval\">ClusterClient &rtrif; broadcastEval</a>"},{"title":"ClusterClient#evalOnCluster","link":"<a href=\"ClusterClient.html#evalOnCluster\">ClusterClient &rtrif; evalOnCluster</a>"},{"title":"ClusterClient#evalOnManager","link":"<a href=\"ClusterClient.html#evalOnManager\">ClusterClient &rtrif; evalOnManager</a>"},{"title":"ClusterClient#fetchClientValues","link":"<a href=\"ClusterClient.html#fetchClientValues\">ClusterClient &rtrif; fetchClientValues</a>"},{"title":"ClusterClient#respawnAll","link":"<a href=\"ClusterClient.html#respawnAll\">ClusterClient &rtrif; respawnAll</a>"},{"title":"ClusterClient#send","link":"<a href=\"ClusterClient.html#send\">ClusterClient &rtrif; send</a>"},{"title":"ClusterManager","link":"<a href=\"ClusterManager.html\">ClusterManager</a>"},{"title":"ClusterManager#_debug","link":"<a href=\"ClusterManager.html#_debug\">ClusterManager &rtrif; _debug</a>"},{"title":"ClusterManager#broadcast","link":"<a href=\"ClusterManager.html#broadcast\">ClusterManager &rtrif; broadcast</a>"},{"title":"ClusterManager#broadcastEval","link":"<a href=\"ClusterManager.html#broadcastEval\">ClusterManager &rtrif; broadcastEval</a>"},{"title":"ClusterManager#createCluster","link":"<a href=\"ClusterManager.html#createCluster\">ClusterManager &rtrif; createCluster</a>"},{"title":"ClusterManager#fetchClientValues","link":"<a href=\"ClusterManager.html#fetchClientValues\">ClusterManager &rtrif; fetchClientValues</a>"},{"title":"ClusterManager#respawnAll","link":"<a href=\"ClusterManager.html#respawnAll\">ClusterManager &rtrif; respawnAll</a>"},{"title":"ClusterManager#spawn","link":"<a href=\"ClusterManager.html#spawn\">ClusterManager &rtrif; spawn</a>"},{"title":"error","link":"<a href=\"Client.html#event:error\">error</a>"},{"title":"death","link":"<a href=\"Cluster.html#event:death\">death</a>"},{"title":"disconnect","link":"<a href=\"Cluster.html#event:disconnect\">disconnect</a>"},{"title":"error","link":"<a href=\"Cluster.html#event:error\">error</a>"},{"title":"ready","link":"<a href=\"Cluster.html#event:ready\">ready</a>"},{"title":"reconnecting","link":"<a href=\"Cluster.html#event:reconnecting\">reconnecting</a>"},{"title":"spawn","link":"<a href=\"Cluster.html#event:spawn\">spawn</a>"},{"title":"clusterCreate","link":"<a href=\"ClusterManager.html#event:clusterCreate\">clusterCreate</a>"},{"title":"debug","link":"<a href=\"ClusterManager.html#event:debug\">debug</a>"},{"title":"message","link":"<a href=\"Shard.html#event:message\">message</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>