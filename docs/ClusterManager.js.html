<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding favicon -->
    

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      ClusterManager.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="5186604" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion collapsed child" id=2079436><div class="accordion-heading child"><a href="Cluster.html">Cluster</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Cluster.html#eval">eval</a></li><li data-type='method'><a href="Cluster.html#fetchClientValue">fetchClientValue</a></li><li data-type='method'><a href="Cluster.html#kill">kill</a></li><li data-type='method'><a href="Cluster.html#request">request</a></li><li data-type='method'><a href="Cluster.html#respawn">respawn</a></li><li data-type='method'><a href="Cluster.html#send">send</a></li><li data-type='method'><a href="Cluster.html#spawn">spawn</a></li></ul></li><li class="accordion collapsed child" id=9230701><div class="accordion-heading child"><a href="ClusterClient.html">ClusterClient</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterClient.html#.getinfo">getinfo</a></li><li data-type='method'><a href="ClusterClient.html#.singleton">singleton</a></li><li data-type='method'><a href="ClusterClient.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterClient.html#evalOnCluster">evalOnCluster</a></li><li data-type='method'><a href="ClusterClient.html#evalOnManager">evalOnManager</a></li><li data-type='method'><a href="ClusterClient.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterClient.html#request">request</a></li><li data-type='method'><a href="ClusterClient.html#respawnAll">respawnAll</a></li><li data-type='method'><a href="ClusterClient.html#send">send</a></li></ul></li><li class="accordion collapsed child" id=456758><div class="accordion-heading child"><a href="ClusterManager.html">ClusterManager</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="ClusterManager.html#_debug">_debug</a></li><li data-type='method'><a href="ClusterManager.html#broadcast">broadcast</a></li><li data-type='method'><a href="ClusterManager.html#broadcastEval">broadcastEval</a></li><li data-type='method'><a href="ClusterManager.html#createCluster">createCluster</a></li><li data-type='method'><a href="ClusterManager.html#fetchClientValues">fetchClientValues</a></li><li data-type='method'><a href="ClusterManager.html#respawnAll">respawnAll</a></li></ul></li></ul> </div><div class="accordion collapsed" id="340133" > <h3 class="accordion-heading">Events<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Client.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:death">death</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:disconnect">disconnect</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:error">error</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:ready">ready</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:reconnecting">reconnecting</a></li><li class="accordion-list" id=""><a href="Cluster.html#event:spawn">spawn</a></li><li class="accordion-list" id=""><a href="ClusterClient.html#event:message">message</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:clusterCreate">clusterCreate</a></li><li class="accordion-list" id=""><a href="ClusterManager.html#event:debug">debug</a></li><li class="accordion-list" id=""><a href="Shard.html#event:message">message</a></li></ul> </div><div class="accordion collapsed" id="8207140" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#ClusterSpawnOptions">ClusterSpawnOptions</a></li></ul> </div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        ClusterManager.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const EventEmitter = require('events');

const fs = require('fs');
const path = require('path');
const os = require('os');

const Util = require('./Util.js');
const Cluster = require('./Cluster.js')

class ClusterManager extends EventEmitter {
  /**
  * @param {string} file Path to your bot file
  * @param {Object} [options] Options for the cluster manager
  * @param {string|number} [options.totalShards='auto'] Number of total internal shards or "auto"
  * @param {string|number} [options.totalClusters='auto'] Number of total Clusters\Process to spawn
  * @param {string[]} [options.shardArgs=[]] Arguments to pass to the clustered script when spawning
  * (only available when using the `process` mode)
  * @param {string[]} [options.execArgv=[]] Arguments to pass to the clustered script executable when spawning
  * @param {boolean} [respawn=true] Whether clusters should automatically respawn upon exiting
  * (only available when using the `process` mode)
  * @param {ClusterManagerMode} [options.mode='worker'] Which mode to use for clustering
  * @param {number[]} [options.shardList] A Array of Internal Shards Ids, which should get spawned
  * @param {Object} [options.keepAlive] Whether Clusters should be automatically respawned, when Heartbeats have not been recieved for a given period of time
  * @param {Number} [options.keepAlive.interval=10000] The Interval for the Hearbeat CheckUp
  * @param {Number} [options.keepAlive.maxClusterRestarts=3] The maximal Amount of Cluster Restarts, which can be executed by the keepAlive Function in less than 1 hour.
  * @param {Number} [options.keepAlive.maxMissedHeartbeats=5] The maximal Amount of missed Hearbeats, upon the Cluster should be respawned.
  * @param {string} [options.token] Token to use for automatic internal shard count and passing to bot file
  */
  constructor(file, options = {}) {
    super();
    options = Util.mergeDefault(
      {
        totalClusters: 'auto',
        totalShards: 'auto',
        shardArgs: [],
        execArgv: [],
        respawn: true,
        mode: 'process',
        keepAlive: {},
        token: process.env.DISCORD_TOKEN,
      },
      options,
    );

    /**
     * Whether clusters should automatically respawn upon exiting
     * @type {boolean}
     */
    this.respawn = options.respawn;

    /**
    * Path to the bot script file
    * @type {string}
    */
    this.file = file;
    if (!file) throw new Error('CLIENT_INVALID_OPTION', 'File', 'specified.');
    if (!path.isAbsolute(file)) this.file = path.resolve(process.cwd(), file);
    const stats = fs.statSync(this.file);
    if (!stats.isFile()) throw new Error('CLIENT_INVALID_OPTION', 'File', 'a file');

    /**
     * Amount of internal shards in total
     * @type {number}
     */
    this.totalShards = options.totalShards || 'auto';
    if (this.totalShards !== 'auto') {
      if (typeof this.totalShards !== 'number' || isNaN(this.totalShards)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'a number.');
      }
      if (this.totalShards &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'at least 1.');
      if (!Number.isInteger(this.totalShards)) {
        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'an integer.');
      }
    }


    /**
    * Amount of total clusters to spawn
    * @type {number}
    */
    this.totalClusters = options.totalClusters || 'auto';
    if (this.totalClusters !== 'auto') {
      if (typeof this.totalClusters !== 'number' || isNaN(this.totalClusters)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'a number.');
      }
      if (this.totalClusters &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'at least 1.');
      if (!Number.isInteger(this.totalClusters)) {
        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'an integer.');
      }
    }

    /**
    * Amount of Shards per Clusters
    * @type {number}
    */
    this.shardsPerClusters = options.shardsPerClusters;
    if (this.shardsPerClusters) {
      if (typeof this.shardsPerClusters !== 'number' || isNaN(this.shardsPerClusters)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of ShardsPerClusters', 'a number.');
      }
      if (this.shardsPerClusters &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of shardsPerClusters', 'at least 1.');
      if (!Number.isInteger(this.shardsPerClusters)) {
        throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of Shards Per Clusters', 'an integer.');
      }
    }

    /**
    * Mode for shards to spawn with
    * @type {ClusterManagerMode}
    */
    this.mode = options.mode;
    if (this.mode !== 'worker' &amp;&amp; this.mode !== "process") {
      throw new RangeError('CLIENT_INVALID_OPTION', 'Cluster mode', '"worker/process"');
    }

    /**
    * An array of arguments to pass to clusters (only when {@link ClusterManager#mode} is `process`)
    * @type {string[]}
    */
    this.shardArgs = options.shardArgs;

    /**
    * An array of arguments to pass to the executable (only when {@link ClusterManager#mode} is `process`)
    * @type {string[]}
    */
    this.execArgv = options.execArgv;

    /**
    * List of internal shard ids this cluster manager spawns
    * @type {string|number[]}
    */
    this.shardList = options.shardList || 'auto';
    if (this.shardList !== 'auto') {
      if (!Array.isArray(this.shardList)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array.');
      }
      this.shardList = [...new Set(this.shardList)];
      if (this.shardList.length &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'shardList', 'at least 1 ID.');
      if (
        this.shardList.some(
          shardID => typeof shardID !== 'number' || isNaN(shardID) || !Number.isInteger(shardID) || shardID &lt; 0,
        )
      ) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'shardList', 'an array of positive integers.');
      }
    }


    /**
    * Whether Clusters should be respawned, when the ClusterClient did not sent any Heartbeats.
    * @type {Object}
    */
    this.keepAlive = options.keepAlive;
    if (typeof this.keepAlive !== 'object') {
      throw new TypeError('CLIENT_INVALID_OPTION', 'keepAlive Options', 'a Object');
    }
    if (Object.keys(options.keepAlive).length !== 0) {
      this.keepAlive.interval = options.keepAlive.interval || 10000;
      this.keepAlive.maxMissedHeartbeats = options.keepAlive.maxMissedHeartbeats || 5;
      this.keepAlive.maxClusterRestarts = options.keepAlive.maxClusterRestarts || 3;
    }





    /**
    * Token to use for obtaining the automatic internal shards count, and passing to bot script
    * @type {?string}
    */
    this.token = options.token ? options.token.replace(/^Bot\s*/i, '') : null;

    /**
    * A collection of all clusters the manager spawned
    * @type {Collection&lt;number, Cluster>}
    */
    this.clusters = new Map();
    this.shardClusterList = null;
    process.env.SHARD_LIST = undefined;
    process.env.TOTAL_SHARDS = this.totalShards;
    process.env.CLUSTER = undefined;
    process.env.CLUSTER_COUNT = this.totalClusters;
    process.env.CLUSTER_MANAGER = true;
    process.env.CLUSTER_MANAGER_MODE = this.mode;
    process.env.KEEP_ALIVE_INTERVAL = this.keepAlive.interval;
    process.env.DISCORD_TOKEN = this.token;


    /**
    * Ongoing promises for calls to {@link ClusterClient#evalOnCluster}, mapped by the `script` they were called with
    * @type {Map&lt;string, Promise>}
    * @private
    */
    this._nonce = new Map();

    /**
    * A Array of IDS[Number], which should be assigned to the spawned Clusters
    * @type {Number[]}
    */
    this.clusterList = options.clusterList || [];

    this._debug(`[START] Cluster Manager has been initalized`)
  }
  /**
   * Spawns multiple internal shards.
   * @typedef {Object} ClusterSpawnOptions
   * @property {number|string} [amount=this.totalShards] Number of internal shards to spawn
   * @property {number} [delay=7000] How long to wait in between spawning each cluster (in milliseconds)
   * @property {number} [tTimeout=30000] The amount in milliseconds to wait until the {@link Client} has become ready
   * before resolving. (-1 or Infinity for no wait)
   * @returns {Promise&lt;Collection&lt;number, Cluster>>}
   */
  async spawn({ amount = this.totalShards, delay = 7000, timeout = -1 } = {}) {
    if (amount === 'auto') {
      amount = await Util.fetchRecommendedShards(this.token, 1000);
      this.totalShards = amount;
      this._debug(`Discord recommanded Total Shard Count of ${amount}`)
    } else {
      if (typeof amount !== 'number' || isNaN(amount)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'a number.');
      }
      if (amount &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'at least 1.');
      if (!Number.isInteger(amount)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of internal shards', 'an integer.');
      }
    }
    let clusteramount = this.totalClusters;
    if (clusteramount === 'auto') {
      clusteramount = os.cpus().length;
      this.totalClusters = clusteramount;
    } else {
      if (typeof clusteramount !== 'number' || isNaN(clusteramount)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'a number.');
      }
      if (clusteramount &lt; 1) throw new RangeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'at least 1.');
      if (!Number.isInteger(clusteramount)) {
        throw new TypeError('CLIENT_INVALID_OPTION', 'Amount of Clusters', 'an integer.');
      }
    }

    if (this.shardList === "auto") this.shardList = [...Array(amount).keys()];

    //Calculate Shards per Cluster:
    if (this.shardsPerClusters) this.totalClusters = Math.ceil(this.shardList.length / this.shardsPerClusters);


    this.shardClusterList = this.shardList.chunk(Math.ceil(this.shardList.length / this.totalClusters));
    if (this.shardClusterList.length !== this.totalClusters) {
      this.totalClusters = this.shardClusterList.length;
    }
    if (this.shardList.some(shardID => shardID >= amount)) {
      throw new RangeError(
        'CLIENT_INVALID_OPTION',
        'Amount of Internal Shards',
        'bigger than the highest shardID in the shardList option.',
      );
    }
    this._debug(`[Spawning Clusters]
    ClusterCount: ${this.totalClusters}
    ShardCount: ${amount}
    ShardList: ${this.shardClusterList.join(', ')}`)
    for (let i = 0; i &lt; this.totalClusters; i++) {
      const promises = [];
      const clusterId = this.clusterList[i] || i;
      const cluster = this.createCluster(clusterId, this.shardClusterList[i], this.totalShards)
      promises.push(cluster.spawn(timeout));
      if (delay > 0 &amp;&amp; this.clusters.size !== this.totalClusters) promises.push(Util.delayFor(delay * this.shardClusterList[i].length));
      await Promise.all(promises); // eslint-disable-line no-await-in-loop
    }
    return this.clusters;
  }

  /**
  * Sends a message to all clusters.
  * @param {*} message Message to be sent to the clusters
  * @returns {Promise&lt;Cluster[]>}
  */
  broadcast(message) {
    const promises = [];
    for (const cluster of this.clusters.values()) promises.push(cluster.send(message));
    return Promise.all(promises);
  }
  /**
  * Creates a single cluster.
  * &lt;warn>Using this method is usually not necessary if you use the spawn method.&lt;/warn>
  * &lt;info>This is usually not necessary to manually specify.&lt;/info>
  * @returns {CLUSTER} Note that the created cluster needs to be explicitly spawned using its spawn method.
  */
  createCluster(id, shardsToSpawn, totalShards) {

    const cluster = new Cluster(this, id, shardsToSpawn, totalShards);
    this.clusters.set(id, cluster);
    /**
     * Emitted upon creating a cluster.
     * @event ClusterManager#clusterCreate
     * @param {Cluster} cluster Cluster that was created
     */
    this.emit('clusterCreate', cluster);

    this._debug(`[CREATE] Created Cluster ${cluster.id}`)
    return cluster;
  }
  /**
  * Evaluates a script on all clusters, or a given cluster, in the context of the {@link Client}s.
  * @param {string|Function} script JavaScript to run on each cluster
  * @param {BroadcastEvalOptions} [options={}] The options for the broadcastEVal
  * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Results of the script execution
  */
  broadcastEval(script, options = {}) {
    if (!script || (typeof script !== 'string' &amp;&amp; typeof script !== 'function')) return Promise.reject(new TypeError('ClUSTERING_INVALID_EVAL_BROADCAST'));
    script = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(options.context)})` : script;
    return this._performOnShards('eval', [script], options.cluster, options.timeout);
  }
  /**
   * Fetches a client property value of each cluster, or a given cluster.
   * @param {string} prop Name of the client property to get, using periods for nesting
   * @param {number} [cluster] Cluster to fetch property from, all if undefined
   * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>}
   * @example
   * manager.fetchClientValues('guilds.cache.size')
   *   .then(results => console.log(`${results.reduce((prev, val) => prev + val, 0)} total guilds`))
   *   .catch(console.error);
   */
  fetchClientValues(prop, cluster) {
    return this._performOnShards('fetchClientValue', [prop], cluster);
  }

  /**
   * Runs a method with given arguments on all clusters, or a given cluster.
   * @param {string} method Method name to run on each cluster
   * @param {Array&lt;*>} args Arguments to pass through to the method call
   * @param {number} [cluster] cluser to run on, all if undefined
   * @param {number} [timeout] the amount of of time to wait until the promise will be rejected
   * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Results of the method execution
   * @private
   */
  _performOnShards(method, args, cluster, timeout) {

    if (this.clusters.size === 0) return Promise.reject(new Error('CLUSTERING_NO_CLUSTERS'));

    if (typeof cluster === 'number') {
      if (this.clusters.has(cluster)) return this.clusters.get(cluster)[method](...args, undefined,timeout);
      return Promise.reject(new Error('CLUSTERING_CLUSTER_NOT_FOUND', cluster));
    }

    if (this.clusters.size !== this.totalClusters) return Promise.reject(new Error('CLUSTERING_IN_PROCESS'));

    const promises = [];
    for (const cl of this.clusters.values()) promises.push(cl[method](...args, undefined, timeout));
    return Promise.all(promises);
  }

  /**
  * Kills all running clusters and respawns them.
  * @param {ClusterRespawnOptions} [options] Options for respawning shards
  * @returns {Promise&lt;Collection&lt;string, Shard>>}
  */
  async respawnAll({ clusterDelay = 5500, respawnDelay = 500, timeout = -1 } = {}) {
    this._nonce.clear()
    let s = 0;
    let i = 0;
    for (const cluster of [...this.clusters.values()]) {
      const promises = [cluster.respawn({ delay: respawnDelay, timeout })];
      if (++s &lt; this.clusters.size &amp;&amp; clusterDelay > 0) promises.push(Util.delayFor(this.shardClusterList[i].length * clusterDelay));
      i++
      await Promise.all(promises); // eslint-disable-line no-await-in-loop
    }
    this._debug('Respawning all Clusters')
    return this.clusters;
  }

  //Custom Functions:

  /**
  * Runs a method with given arguments on the Manager itself
  * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Results of the script execution
  * @private
  */
  async evalOnManager(script) {
    const _eval = typeof script === 'function' ? `(${script})(this)` : script;
    let result;
    let error;
    try {
      result = await eval(script)
    } catch (err) {
      error = err;
    }
    const promise = { _results: result, _error: error }
    return promise;
  }

  /**
  * Runs a method with given arguments on the provided Cluster Client
  * @returns {Promise&lt;*>|Promise&lt;Array&lt;*>>} Results of the script execution
  * @private
  */
  evalOnCluster(script, options) {
    script = typeof script === 'function' ? `(${script})(this, ${JSON.stringify(options.context)})` : script;
    if(options.hasOwnProperty('guildId')){
      options.shard = Util.shardIdForGuildId(options.guildId, this.totalShards)
    } 
    if (options.hasOwnProperty('shard')) {
      const findcluster = [...this.clusters.values()].find(i => i.shardlist.includes(options.shard));
      options.cluster = findcluster ? findcluster.id : 0;
    }
    const cluster = this.clusters.get(options.cluster);
    if (!cluster) return Promise.reject(new Error('CLUSTER_DOES_NOT_EXIST', options.cluster));
    if (!cluster.process &amp;&amp; !cluster.worker) return Promise.reject(new Error('CLUSTERING_NO_CHILD_EXISTS', cluster.id));
    return new Promise((resolve, reject) => {
      const nonce = options.nonce;
      this._nonce.set(nonce, { resolve, reject, requestcluster: options.requestcluster });
      const sent = cluster.send({ _sClusterEvalRequest: script, nonce, cluster: options.cluster }, void 0, void 0, e => {
        if (e) reject(new Error(`Failed to deliver Message to cluster: ${e}`));
        setTimeout(() => {
          if (this._nonce.has(nonce)) {
            this._nonce.get(nonce).reject(new Error("Eval Request Timedout"));
            this._nonce.delete(nonce);
          }
        }, (options.timeout || 10000));
      });
      if (!sent) reject(new Error("CLUSTERING_IN_PROCESS or CLUSTERING_DIED"));
    }).catch((e) => (new Error(e.toString())))
  }


  /**
   * Logsout the Debug Messages
   * &lt;warn>Using this method just emits the Debug Event.&lt;/warn>
   * &lt;info>This is usually not necessary to manually specify.&lt;/info>
   * @returns {log} returns the log message
   */
  _debug(message, cluster) {
    let log;
    if (cluster === undefined) {
      log = `[CM => Manager] ` + message;
    } else {
      log = `[CM => Cluster ${cluster}] ` + message;
    }
    /**
     * Emitted upon recieving a message
     * @event ClusterManager#debug
     * @param {log} Message, which was recieved
    */
    this.emit('debug', log)
    return log;
  }

}
module.exports = ClusterManager;

Object.defineProperty(Array.prototype, 'chunk', {
  value: function (chunkSize) {
    var R = [];
    for (var i = 0; i &lt; this.length; i += chunkSize)
      R.push(this.slice(i, i + chunkSize));
    return R;
  }
});
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Cluster","link":"<a href=\"Cluster.html\">Cluster</a>"},{"title":"Cluster#eval","link":"<a href=\"Cluster.html#eval\">Cluster &rtrif; eval</a>"},{"title":"Cluster#fetchClientValue","link":"<a href=\"Cluster.html#fetchClientValue\">Cluster &rtrif; fetchClientValue</a>"},{"title":"Cluster#kill","link":"<a href=\"Cluster.html#kill\">Cluster &rtrif; kill</a>"},{"title":"Cluster#request","link":"<a href=\"Cluster.html#request\">Cluster &rtrif; request</a>"},{"title":"Cluster#respawn","link":"<a href=\"Cluster.html#respawn\">Cluster &rtrif; respawn</a>"},{"title":"Cluster#send","link":"<a href=\"Cluster.html#send\">Cluster &rtrif; send</a>"},{"title":"Cluster#spawn","link":"<a href=\"Cluster.html#spawn\">Cluster &rtrif; spawn</a>"},{"title":"ClusterClient","link":"<a href=\"ClusterClient.html\">ClusterClient</a>"},{"title":"ClusterClient.getinfo","link":"<a href=\"ClusterClient.html#.getinfo\">ClusterClient.getinfo &rtrif; undefined</a>"},{"title":"ClusterClient.singleton","link":"<a href=\"ClusterClient.html#.singleton\">ClusterClient.singleton &rtrif; undefined</a>"},{"title":"ClusterClient#broadcastEval","link":"<a href=\"ClusterClient.html#broadcastEval\">ClusterClient &rtrif; broadcastEval</a>"},{"title":"ClusterClient#evalOnCluster","link":"<a href=\"ClusterClient.html#evalOnCluster\">ClusterClient &rtrif; evalOnCluster</a>"},{"title":"ClusterClient#evalOnManager","link":"<a href=\"ClusterClient.html#evalOnManager\">ClusterClient &rtrif; evalOnManager</a>"},{"title":"ClusterClient#fetchClientValues","link":"<a href=\"ClusterClient.html#fetchClientValues\">ClusterClient &rtrif; fetchClientValues</a>"},{"title":"ClusterClient#request","link":"<a href=\"ClusterClient.html#request\">ClusterClient &rtrif; request</a>"},{"title":"ClusterClient#respawnAll","link":"<a href=\"ClusterClient.html#respawnAll\">ClusterClient &rtrif; respawnAll</a>"},{"title":"ClusterClient#send","link":"<a href=\"ClusterClient.html#send\">ClusterClient &rtrif; send</a>"},{"title":"ClusterManager","link":"<a href=\"ClusterManager.html\">ClusterManager</a>"},{"title":"ClusterManager#_debug","link":"<a href=\"ClusterManager.html#_debug\">ClusterManager &rtrif; _debug</a>"},{"title":"ClusterManager#broadcast","link":"<a href=\"ClusterManager.html#broadcast\">ClusterManager &rtrif; broadcast</a>"},{"title":"ClusterManager#broadcastEval","link":"<a href=\"ClusterManager.html#broadcastEval\">ClusterManager &rtrif; broadcastEval</a>"},{"title":"ClusterManager#createCluster","link":"<a href=\"ClusterManager.html#createCluster\">ClusterManager &rtrif; createCluster</a>"},{"title":"ClusterManager#fetchClientValues","link":"<a href=\"ClusterManager.html#fetchClientValues\">ClusterManager &rtrif; fetchClientValues</a>"},{"title":"ClusterManager#respawnAll","link":"<a href=\"ClusterManager.html#respawnAll\">ClusterManager &rtrif; respawnAll</a>"},{"title":"error","link":"<a href=\"Client.html#event:error\">error</a>"},{"title":"death","link":"<a href=\"Cluster.html#event:death\">death</a>"},{"title":"disconnect","link":"<a href=\"Cluster.html#event:disconnect\">disconnect</a>"},{"title":"error","link":"<a href=\"Cluster.html#event:error\">error</a>"},{"title":"ready","link":"<a href=\"Cluster.html#event:ready\">ready</a>"},{"title":"reconnecting","link":"<a href=\"Cluster.html#event:reconnecting\">reconnecting</a>"},{"title":"spawn","link":"<a href=\"Cluster.html#event:spawn\">spawn</a>"},{"title":"message","link":"<a href=\"ClusterClient.html#event:message\">message</a>"},{"title":"clusterCreate","link":"<a href=\"ClusterManager.html#event:clusterCreate\">clusterCreate</a>"},{"title":"debug","link":"<a href=\"ClusterManager.html#event:debug\">debug</a>"},{"title":"message","link":"<a href=\"Shard.html#event:message\">message</a>"},{"title":"ClusterSpawnOptions","link":"<a href=\"global.html#ClusterSpawnOptions\">ClusterSpawnOptions</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>
